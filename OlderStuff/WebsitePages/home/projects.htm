<div>
  <h2>Projects <small>Some of the Projects I have worked on in my Undergrad</small></h2>
    </div>
    <div class="r">
    </div>
  </div>
</div>
    </p>
</div>
<div class="block">
    <div class="titleBar">
        <div class="l"></div>
        <div class="m">
            <h3>Github</h3>
            <h4>Current Projects</h4>
        </div>
        <div class="r">
            <button class="tButton" onclick="changeTo('Github');">
                <!--BUTTON_FORWARD{Explore}-->
            </button>
        </div>
    </div>
    <p> Currently working on a few small projects with some friends. They
        have to do with the Internet of Things.
    </p>
</div>

<div class="block">
    <div class="titleBar">
        <div class="l"></div>
        <div class="m">
            <h3>Research</h3>
            <h4>Human-Centered Cloud Robotics</h4>
        </div>
        <div class="r">
            <button class="tButton" onclick="changeTo('PubSub');">
                <!--BUTTON_FORWARD{Explore}-->
            </button>
        </div>
    </div>
    <p>
        <ul>
            <li>Analyze pubsub architectures ability to handle realtime applications.
            </li>

            <li> Simulating on ball plate model to analyze control over realtime
                environment </li>

            <li>Comparing MQTT and Kafka.</li>

            <li>Using Mininet and Python scripts to generate network topology/collect
                data.</li>
        </ul>
    </p>
    <div class ="imgContain">
        <img src="resources/pubSubRep.png" style="height: 17em !important;" >
        <p1> <br>Realtime Publish and Subscribe </p1>
    </div>
    <h5>Diagram explanation:</h5>
    <p> The plant publishes <b> the location of the ball and where the ball is
        desired to be </b> on the broker. The broker then sends that info to
        anyone who is subscribed (in this case the controller). The controller
        processes that and publishes <b>how the plate should be tilted</b> in
        order for the ball to move towards its desired location on the broker,
        which then sends that to whoever is subscribed (in this case the plant).
        The plant then changes the tilt and measures the results as compared to
        the best possible results (with no latency).
    </p>
</div>

<div class="block">
    <div class="titleBar">
        <div class="l"></div>
        <div class="m">
            <h3>Research Science Internship</h3>
            <h4>DIMACS REU at Rutgers University</h4>
        </div>
        <div class="r">
            <button class="tButton" onclick="changeTo('Multi-Robot');">
                <!--BUTTON_FORWARD{Explore}-->
            </button>
        </div>
    </div>
    <p>
        <ul>
            <li>Wrote a research paper on results.</li>

            <li>Simulations were done in Python.</li>

            <li>Analyze traffic in a multi-robot environment with multi-agent
                simulations.</li>

            <li>Specifically looking for sharp-transition in behavior.</li>
        </ul>
    </p>
    <div class="container-fluid container">
      <div class="col-md-4"></div>
      <div class="thumbnail col-md-6">
        <img src="resources/DiscreteSmaller.gif">
	<div class="caption">
          <p>Discrete Multi-Robot Environment Simulation </p>
	</div>
      </div>
    </div>
    <h5> Diagram explanation:</h5>
    <p> This is a simulation of a multi-robot environment in which basic path
    planning is implemented. It is done in a discrete case to allow for easier
    path planning. The grid size and hexagonal shape is chosen so that a disc
    with radius <em>r</em> will not collide with another disc of radius <em>r</em>.
        <br> Pseudo code
        <ol>
            <li> A Starting and Ending point on the graph are randomly chosen
            for each disc. </li>
            <li> A breadth first search is done from each discs goal node, that
            is saved on the node data structure</li>
            <li> On each discrete transition, every node tries to move closer to
            its goal node, while trying not to run into another disc, using info
            on the nodes </li>
            <li> Random priorities are decided among the discs and the next step
            is computed. </li>
            <li> Repeat step 4 until all nodes are at their respective goal
            states. </li>
        </ol>
    </p>
</div>
